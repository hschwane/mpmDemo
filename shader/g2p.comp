#version 450 core
#extension GL_ARB_compute_variable_group_size : require

#include "kernel.glsl"

// --------------------------------------
// uniforms
uniform int numParticles;
uniform vec2 simDomain;
uniform float timestep;
uniform float particleMass;
uniform float gridCellSize=1;
uniform float apicFactor=4.0f;

// --------------------------------------
// texture bindings
uniform layout(rgba32f) restrict readonly image2D grid;

// --------------------------------------
// buffer bindings
layout(binding=2,std430) buffer ParticlePosition { vec2 particlePosition[]; };
layout(binding=3,std430) buffer ParticleVelocity { vec2 particleVelocity[]; };
layout(binding=4,std430) buffer ParticleF { mat2 particleF[]; };
layout(binding=5,std430) buffer ParticleAffine { mat2 particleAffine[]; };
layout(binding=6,std430) buffer ParticleVolume { float particleVolume[]; };

// --------------------------------------
// compute parameters
layout(local_size_variable) in;

void main()
{
    int problemSize = numParticles;
    for(  int id = int(gl_GlobalInvocationID.x); id < problemSize; id += int(gl_NumWorkGroups.x * gl_LocalGroupSizeARB.x))
    {
        vec2 pPos = particlePosition[id];


        // loop over cells, compute affine APIC matrix and velocity
        mat2 affine = mat2(0);
        vec2 pVel = vec2(0);
        const ivec2 middleCellId = ivec2(pPos);
        for( int cidy = middleCellId.y-1; cidy < middleCellId.y+2; cidy++)
            for( int cidx = middleCellId.x -1; cidx < middleCellId.y+2; cidx++)
            {
                ivec2 gridCell = ivec2(cidx,cidy);
                vec2 gridCellPos = vec2(gridCell) + vec2(0.5,0.5);

                float wip = kernel(gridCellPos,pPos,gridCellSize);
                vec2 xdiff = gridCellPos - pPos;

                vec3 velm = imageLoad(grid,gridCell).xyz;

                pVel += wip * velm.xy;
//                pVel += velm.xy;
//                affine += wip * mat2( velm.x * xdiff.x, velm.x * xdiff.y,
//                                        velm.y * xdiff.x, velm.y * xdiff.y);
            }

        // update position
        pPos += timestep * pVel;

        // update F
//        mat2 pF = (mat2(1.0f) + timestep * apicFactor * affine) * particleF[id];

        // clamp to simulation domain for safety
        pPos = clamp(pPos, vec2(2,2), simDomain-vec2(3,3));

        // store updated values
        particlePosition[id] = pPos;
        particleVelocity[id] = pVel;
        particleAffine[id] = affine;
//        particleF[id] = pF;
    }
}
